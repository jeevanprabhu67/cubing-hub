<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Cubing Hub</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { margin:0; font-family: Arial, Helvetica, sans-serif; background:#fff; color:#000; min-height:100vh; }
    body::before { content:""; position:fixed; inset:0; background:url('https://upload.wikimedia.org/wikipedia/commons/6/6d/Rubik%27s_cube_scrambled.svg') center/420px no-repeat; opacity:0.08; pointer-events:none; z-index:-1; }
    .container { max-width:980px; margin:36px auto; padding:0 16px; }
    .card { background:#000; color:#fff; border-radius:14px; box-shadow:0 16px 40px rgba(0,0,0,0.35); border:1px solid #1f1f1f; padding:22px; text-align:center; }
    h1, h2, h3 { margin: 0 0 16px 0; }
    .row { display:flex; flex-wrap:wrap; justify-content:center; gap:12px; }
    .btn { display:inline-block; margin:8px; padding:12px 18px; background:#0078d7; color:#fff; border:none; border-radius:10px; cursor:pointer; font-weight:700; min-width:220px; }
    .btn:hover { background:#005a9e; }
    .stats { font-weight:700; color:#5fe3a1; margin:10px 0 16px; }
    .q { font-size:1.1rem; margin:10px 0 16px; }
    .grid { display:grid; grid-template-columns:1fr 1fr; gap:10px; text-align:left; }
    @media (max-width:640px){ .grid { grid-template-columns:1fr; } }
    .opt { background:#1b1b1b; border:1px solid #2a2a2a; border-radius:10px; padding:10px; cursor:pointer; color:#fff; }
    table { width:100%; border-collapse:collapse; margin-top:14px; }
    th, td { border:1px solid #2a2a2a; padding:10px; text-align:left; vertical-align:top; }
    th { background:#0f0f0f; } td { background:#111; }
    .thumb { width:120px; height:80px; border:1px solid #2a2a2a; border-radius:8px; background:#222; display:flex; align-items:center; justify-content:center; color:#fff; font-weight:700; }
    img.alg { width:120px; height:80px; border:1px solid #2a2a2a; border-radius:8px; object-fit:contain; background:#222; }
    input[type="text"]{ width:100%; padding:10px; border-radius:8px; border:1px solid #2a2a2a; background:#1b1b1b; color:#fff; font-size:1rem; margin:8px 0 12px; }
    .note { color:#cfcfcf; font-size:0.95rem; margin-bottom:10px; }
    .divider { height:1px; background:#2a2a2a; margin:16px 0; }
    canvas { background:#0f0f0f; border-radius:10px; margin:12px 0; }
  </style>
</head>
<body>
  <div class="container"><div class="card" id="app"></div></div>

  <script>
    // Persistence keys
    const COIN_KEY='cubingHubCoins', OWNED_KEY='cubingHubOwned', SOLVES_KEY='cubingHubSolves', BESTS_KEY='cubingHubBests';

    // Persistence helpers
    const getCoins = ()=> parseInt(localStorage.getItem(COIN_KEY)||'0',10);
    const setCoins = v => localStorage.setItem(COIN_KEY,String(v));
    const getOwned = ()=> { try{ return new Set(JSON.parse(localStorage.getItem(OWNED_KEY)||'[]')); } catch{ return new Set(); } };
    const setOwned = set => localStorage.setItem(OWNED_KEY, JSON.stringify([...set]));
    const getSolves = ()=> { try{ return JSON.parse(localStorage.getItem(SOLVES_KEY)||'[]'); } catch{ return []; } };
    const setSolves = arr => localStorage.setItem(SOLVES_KEY, JSON.stringify(arr));
    const getBests = ()=> { try{ return JSON.parse(localStorage.getItem(BESTS_KEY)||'{"bestSingle":null,"bestAo5":null,"bestAo12":null}'); } catch{ return {bestSingle:null,bestAo5:null,bestAo12:null}; } };
    const setBests = obj => localStorage.setItem(BESTS_KEY, JSON.stringify(obj));

    // App state
    const app=document.getElementById('app');
    let coins=getCoins(), owned=getOwned();

    // PLL reference
    const PLL = { T: "R U R' U' R' F R2 U' R' U' R U R' F'" };
    const TPERM = PLL.T;

    // Shop items
    const SHOP_ITEMS = [
      {id:"F2L2LOOK", name:"2-Look F2L", cost:10},
      {id:"OLL_FULL", name:"OLL (Full)", cost:20},
      {id:"ZBLL_FULL", name:"ZBLL (Sample)", cost:50}
    ];

    // Quiz questions (20)
    const QUESTIONS = [
      {q:"What is the 3×3 WR?", options:["3.47s","3.13s","3.21s","2.96s"], answer:1},
      {q:"What does DNF mean?", options:["Did Not Finish","Does Not Fit","Deck Not Found","Deemed Not Fair"], answer:0},
      {q:"Penalty if misaligned >45° at finish?", options:["+2","DNF","No penalty","Re-scramble"], answer:1},
      {q:"Inspection 15–17s penalty?", options:["No penalty","+2","DNF","Disqualification"], answer:1},
      {q:"God’s Number for 3×3?", options:["17","18","20","22"], answer:2},
      {q:"CFOP stands for?", options:["Cross,F2L,OLL,PLL","Corner First","Center First","Cross,F2L,Orientation,Permutation"], answer:0},
      {q:"Which step orients the last layer?", options:["F2L","OLL","PLL","Cross"], answer:1},
      {q:"WCA stands for?", options:["World Cubing Association","World Cube Association","World Contest of Algorithms","World Championship Athletics"], answer:1},
      {q:"Approx. number of 3×3 states?", options:["43 million","43 billion","43 quintillion","4.3 million"], answer:2},
      {q:"Scramble notation uses?", options:["Face turns with ',2","Edge rotations","Vertex swaps","Block moves"], answer:0},
      {q:"Timer start +2 can occur when?", options:["Hands not on sensors","Starting before green light","Touch cube during inspection","Not resetting"], answer:1},
      {q:"PLL primarily?", options:["Orients LL","Permutes LL","Solves F2L","Creates cross"], answer:1},
      {q:"DNF due to timer stop can be:", options:["One hand only","Not stopping in 0.5s","Failing both sensors","Stopping late"], answer:2},
      {q:"Which event is one-handed?", options:["3×3 OH","Pyraminx","Skewb","Clock"], answer:0},
      {q:"OLL skip means:", options:["No algs","OLL solved after F2L","PLL unnecessary","Cross solved"], answer:1},
      {q:"Best early CFOP improvement:", options:["Full OLL","Full PLL","Full F2L","No algs"], answer:1},
      {q:"+2 at finish for alignment:", options:["Any misalignment","≤45° misalignment","90° misaligned","Judge only"], answer:1},
      {q:"Inspection time allowed?", options:["10s","12s","15s","20s"], answer:2},
      {q:"TPS stands for?", options:["Turns Per Second","Twists Per Solve","Time Per Step","Total Permutation Set"], answer:0},
      {q:"Pyraminx notation includes?", options:["R U L F D B","Face + tip moves","Slice moves","Rotations only"], answer:1}
    ];

    // Revive set
    const REVIVE_PLL = [
      {q:"Which PLL swaps opposite edges?", options:["H perm","Z perm","Ua perm","Ub perm"], answer:0},
      {q:"Which PLL swaps adjacent edges?", options:["Z perm","H perm","Ua perm","Ub perm"], answer:1},
      {q:"Which PLL cycles three edges clockwise?", options:["Ua perm","Ub perm","T perm","Y perm"], answer:0},
      {q:"Which PLL cycles three edges counterclockwise?", options:["Ua perm","Ub perm","T perm","Y perm"], answer:1}
    ];

    // F2L 2-Look sample
    const F2L2LOOK_ALGS = [
      {name:"2-Look F2L (basic pair insert)", alg:"U R U' R'"},
      {name:"2-Look F2L (alt insert)", alg:"y' U' R' U R"}
    ];

    // Full OLL diagrams (57)
    const OLL = Array.from({length:57}, (_,i)=>({
      name: `OLL ${i+1}`,
      alg: "(Fill with preferred alg)",
      img: `https://algdb.net/img/oll/oll${i+1}.png`
    }));

    // Sample ZBLL
    const ZBLL = [
      {name:"ZBLL U1", alg:"(See algdb)", img:"https://algdb.net/img/zbll/u1.png"},
      {name:"ZBLL U2", alg:"(See algdb)", img:"https://algdb.net/img/zbll/u2.png"},
      {name:"ZBLL H1", alg:"(See algdb)", img:"https://algdb.net/img/zbll/h1.png"},
      {name:"ZBLL Pi1", alg:"(See algdb)", img:"https://algdb.net/img/zbll/pi1.png"},
      {name:"ZBLL T1", alg:"(See algdb)", img:"https://algdb.net/img/zbll/t1.png"}
    ];

    // Story
    const STORY = [
      { text:"You wake up in a cubing arena. A giant scrambled cube floats before you.", choices:[{label:"Try to solve it",next:1,reward:2},{label:"Walk away",next:2,reward:0}] },
      { text:"You grab the cube and start turning. The crowd cheers!", choices:[{label:"Keep solving",next:3,reward:5},{label:"Drop the cube",next:2,reward:0}] },
      { text:"You leave the arena. The adventure ends.", choices:[] },
      { text:"You solve the cube! Confetti rains down. You are crowned champion.", choices:[] }
    ];
    let storyIndex=0;

    // Timer state
    let timerRunning=false, startTime=0;
    let solves = getSolves(); // array of seconds (number)
    let bests = getBests(); // {bestSingle, bestAo5, bestAo12}

    // Entry
    renderMenu();

    // Menu
    function renderMenu(){
      app.innerHTML = `
        <h1>Cubing Hub</h1>
        <div class="row">
          <button class="btn" onclick="renderScramble()">Scramble Generator</button>
          <button class="btn" onclick="startQuiz()">Quiz (20 Qs + revive)</button>
          <button class="btn" onclick="renderShop()">Shop</button>
          <button class="btn" onclick="renderSpreadsheet()">Algorithm Spreadsheet</button>
          <button class="btn" onclick="renderGuide()">How to Solve</button>
          <button class="btn" onclick="renderStory()">Game</button>
          <button class="btn" onclick="renderTimer()">Timer</button>
        </div>
        <div class="stats">Coins: ${coins}</div>
      `;
      // Remove global key handler when not in timer
      document.onkeydown = null;
    }

    // Scramble generator
    function renderScramble(){
      const s = generateScramble(20);
      app.innerHTML = `
        <h2>Scramble Generator</h2>
        <div class="q">Your scramble:</div>
        <div class="stats">${s}</div>
        <div class="row">
          <button class="btn" onclick="renderScramble()">Regenerate</button>
          <button class="btn" onclick="renderMenu()">Back to Main</button>
        </div>
      `;
    }
    function generateScramble(len=20){
      const faces=["R","L","U","D","F","B"], mods=["","'","2"];
      const axis = f => (f==="R"||f==="L")?"x" : (f==="U"||f==="D")?"y" : "z";
      let seq=[], last=null;
      for(let i=0;i<len;i++){
        let f;
        do{ f = faces[Math.floor(Math.random()*faces.length)]; }
        while(last && axis(f)===axis(last));
        last = f;
        seq.push(f + mods[Math.floor(Math.random()*mods.length)]);
      }
      return seq.join(" ");
    }

    // Quiz
    let deck=[], idx=0, score=0, usedReviveMC=false, usedReviveInput=false;
    function startQuiz(){ deck=QUESTIONS.slice(); idx=0; score=0; usedReviveMC=false; usedReviveInput=false; renderQuestion(); }
    function renderQuestion(){
      if(idx>=deck.length) return renderSummary();
      const q = deck[idx];
      app.innerHTML = `
        <h2>Quiz</h2>
        <div class="stats">Q ${idx+1}/${deck.length} • Score ${score} • Coins ${coins}</div>
        <div class="q">${q.q}</div>
        <div class="grid">${q.options.map((o,i)=>`<button class="opt" onclick="choose(${i})">${o}</button>`).join("")}</div>
        <div class="row"><button class="btn" onclick="renderMenu()">Back to Main</button></div>
      `;
    }
    function choose(i){
      const q=deck[idx];
      if(i===q.answer){ score++; coins++; setCoins(coins); idx++; renderQuestion(); }
      else {
        if(!usedReviveMC){ usedReviveMC=true; reviveMC(); }
        else if(!usedReviveInput){ usedReviveInput=true; reviveInput(); }
        else { alert("Out of revives! Returning to main."); renderMenu(); }
      }
    }
    function reviveMC(){
      const r = REVIVE_PLL[Math.floor(Math.random()*REVIVE_PLL.length)];
      app.innerHTML = `
        <h2>Revive Challenge — PLL</h2>
        <div class="q">${r.q}</div>
        <div class="grid">${r.options.map((o,i)=>`<button class="opt" onclick="reviveMCAnswer(${i},${r.answer})">${o}</button>`).join("")}</div>
        <div class="row"><button class="btn" onclick="renderMenu()">Back to Main</button></div>
      `;
    }
    function reviveMCAnswer(choice, correct){
      if(choice===correct){ idx++; renderQuestion(); } else { reviveInput(); }
    }
    function reviveInput(){
      app.innerHTML = `
        <h2>Final Revive — Type the T-perm Algorithm</h2>
        <div class="note">Spacing differences are OK.</div>
        <div class="q"><b>Reference:</b> ${TPERM}</div>
        <input type="text" id="algInput" placeholder="Type the T-perm algorithm here" />
        <div class="row">
          <button class="btn" onclick="checkTperm()">Submit</button>
          <button class="btn" onclick="renderMenu()">Back to Main</button>
        </div>
      `;
    }
    function checkTperm(){
      const val = (document.getElementById('algInput').value||'').trim().replace(/\s+/g,' ');
      const ref = TPERM.trim().replace(/\s+/g,' ');
      if(val.toUpperCase() === ref.toUpperCase()){ alert("Revived!"); idx++; renderQuestion(); }
      else { alert("Incorrect T-perm. Returning to main."); renderMenu(); }
    }
    function renderSummary(){
      const pct = Math.round((score/deck.length)*100);
      app.innerHTML = `
        <h2>Quiz Complete</h2>
        <div class="q">Score: ${score}/${deck.length} (${pct}%)</div>
        <div class="stats">Coins: ${coins}</div>
        <div class="row">
          <button class="btn" onclick="startQuiz()">Play Again</button>
          <button class="btn" onclick="renderMenu()">Back to Main</button>
        </div>
      `;
    }

    // Shop
    function renderShop(){
      app.innerHTML = `
        <h2>Shop</h2>
        <div class="stats">Your Coins: ${coins}</div>
        <table>
          <tr><th>Item</th><th>Cost</th><th>Status</th><th>Action</th></tr>
          ${SHOP_ITEMS.map(i=>{
            const has = owned.has(i.id);
            return `<tr>
              <td>${i.name}</td>
              <td>${i.cost}</td>
              <td>${has?"Owned":"Not owned"}</td>
              <td>${has?"<span>Purchased</span>":`<button class="btn" onclick="buy('${i.id}',${i.cost})">Buy</button>`}</td>
            </tr>`;
          }).join("")}
        </table>
        <div class="row"><button class="btn" onclick="renderMenu()">Back to Main</button></div>
      `;
    }
    function buy(id,cost){
      if(owned.has(id)) return alert("Already purchased.");
      if(coins<cost) return alert("Not enough coins!");
      coins-=cost; setCoins(coins); owned.add(id); setOwned(owned);
      alert("Purchased!"); renderShop();
    }

    // Spreadsheet
    function renderSpreadsheet(){
      const unlocked = [
        owned.has("F2L2LOOK") ? "2-Look F2L" : null,
        owned.has("OLL_FULL") ? "OLL (Full)" : null,
        owned.has("ZBLL_FULL") ? "ZBLL (Sample)" : null
      ].filter(Boolean);

      const pllRows = `<tr><td>T-perm</td><td>${TPERM}</td><td><div class="thumb">T</div></td></tr>`;
      let extrasHTML = "";

      if(owned.has("F2L2LOOK")){
        extrasHTML += `
          <div class="divider"></div>
          <h3>2-Look F2L</h3>
          <table>
            <tr><th>Name</th><th>Algorithm</th><th>Picture</th></tr>
            ${F2L2LOOK_ALGS.map(x=>`
              <tr>
                <td>${x.name}</td>
                <td>${x.alg}</td>
                <td><div class="thumb">F2L</div></td>
              </tr>`).join("")}
          </table>`;
      }

      if(owned.has("OLL_FULL")){
        const ollRows = OLL.map(c=>`
          <tr>
            <td>${c.name}</td>
            <td>${c.alg}</td>
            <td><img class="alg" src="${c.img}" alt="${c.name}"></td>
          </tr>`).join('');
        extrasHTML += `
          <div class="divider"></div>
          <h3>OLL (57 cases)</h3>
          <table>
            <tr><th>Name</th><th>Algorithm</th><th>Picture</th></tr>
            ${ollRows}
          </table>`;
      }

      if(owned.has("ZBLL_FULL")){
        const zbllRows = ZBLL.map(c=>`
          <tr>
            <td>${c.name}</td>
            <td>${c.alg}</td>
            <td><img class="alg" src="${c.img}" alt="${c.name}"></td>
          </tr>`).join('');
        extrasHTML += `
          <div class="divider"></div>
          <h3>ZBLL (sample)</h3>
          <table>
            <tr><th>Name</th><th>Algorithm</th><th>Picture</th></tr>
            ${zbllRows}
          </table>`;
      }

      app.innerHTML = `
        <h2>Algorithm Spreadsheet</h2>
        ${unlocked.length?`<div class="note"><b>Unlocked:</b> ${unlocked.join(", ")}</div>`:`<div class="note">Unlock more methods in the Shop to reveal extra sections.</div>`}
        <div class="divider"></div>
        <h3>PLL</h3>
        <table>
          <tr><th>Case</th><th>Algorithm</th><th>Picture</th></tr>
          ${pllRows}
        </table>
        ${extrasHTML}
        <div class="row"><button class="btn" onclick="renderMenu()">Back to Main</button></div>
      `;
    }

    // Guide
    function renderGuide(){
      app.innerHTML = `
        <h2>How to solve a Rubik's Cube (CFOP)</h2>
        <div class="q"><b>Step 1 — Cross:</b> Build a cross matching edge colors to centers.</div><div class="thumb">Cross</div>
        <div class="q"><b>Step 2 — F2L:</b> Pair corner+edge and insert for all four slots.</div><div class="thumb">F2L</div>
        <div class="q"><b>Step 3 — OLL:</b> Orient last layer to make the top solid color.</div><div class="thumb">OLL</div>
        <div class="q"><b>Step 4 — PLL:</b> Permute the last layer to finish.</div><div class="thumb">PLL</div>
        <div class="row">
          <button class="btn" onclick="renderSpreadsheet()">Open Spreadsheet</button>
          <button class="btn" onclick="renderMenu()">Back to Main</button>
        </div>
      `;
    }

    // Story
    function renderStory(){
      const scene = STORY[storyIndex];
      let choiceHTML = "";
      if(scene.choices.length){
        choiceHTML = `<div class="row">` + scene.choices.map(c=>`
          <button class="btn" onclick="chooseStory(${c.next},${c.reward})">${c.label}</button>
        `).join("") + `</div>`;
      } else {
        choiceHTML = `<div class="row">
          <button class="btn" onclick="restartStory()">Play Again</button>
          <button class="btn" onclick="renderMenu()">Back to Main</button>
        </div>`;
      }
      app.innerHTML = `
        <h2>Game</h2>
        <div class="q">${scene.text}</div>
        ${choiceHTML}
        <div class="stats">Coins: ${coins}</div>
      `;
    }
    function chooseStory(nextIndex,reward){ coins+=reward; setCoins(coins); storyIndex=nextIndex; renderStory(); }
    function restartStory(){ storyIndex=0; renderStory(); }

    // Timer
    function renderTimer(){
      const scramble = generateScramble(20);
      app.innerHTML = `
        <h2>Timer</h2>
        <div class="q">Scramble:</div>
        <div class="stats" id="scramble">${scramble}</div>
        <h1 id="timerDisplay" style="color:lime">0.00</h1>
        <div class="note">Press SPACE to start/stop</div>

        <div class="divider"></div>
        <h3>Stats</h3>
        <div id="statsArea"></div>

        <div class="divider"></div>
        <h3>Progress graph</h3>
        <canvas id="chart" width="800" height="300"></canvas>

        <div class="divider"></div>
        <h3>Solve history</h3>
        <div id="historyArea"></div>

        <div class="row">
          <button class="btn" onclick="resetSession()">Reset Session</button>
          <button class="btn" onclick="exportCSV()">Export CSV</button>
          <button class="btn" onclick="renderMenu()">Back</button>
        </div>
      `;
      document.onkeydown=(e)=>{ if(e.code==="Space"){ e.preventDefault(); toggleTimer(); } };
      updateStatsUI();
      drawChart();
      renderHistory();
    }

    function toggleTimer(){
      const display=document.getElementById("timerDisplay");
      if(!timerRunning){
        startTime=performance.now();
        timerRunning=true;
        display.style.color="red";
        updateTimer();
      } else {
        timerRunning=false;
        const end=performance.now();
        const time=((end-startTime)/1000);
        solves.push(time);
        setSolves(solves);

        // Update bests
        const currentAo5 = computeAo(5);
        const currentAo12 = computeAo(12);
        bests.bestSingle = bests.bestSingle==null ? time : Math.min(bests.bestSingle, time);
        if(currentAo5!=null) bests.bestAo5 = bests.bestAo5==null ? currentAo5 : Math.min(bests.bestAo5, currentAo5);
        if(currentAo12!=null) bests.bestAo12 = bests.bestAo12==null ? currentAo12 : Math.min(bests.bestAo12, currentAo12);
        setBests(bests);

        display.style.color="lime";
        // new scramble
        document.getElementById("scramble").textContent = generateScramble(20);

        updateStatsUI();
        drawChart();
        renderHistory();
      }
    }
    function updateTimer(){
      if(!timerRunning) return;
      const elapsed=(performance.now()-startTime)/1000;
      document.getElementById("timerDisplay").textContent = elapsed.toFixed(2);
      requestAnimationFrame(updateTimer);
    }

    // Stats UI
    function updateStatsUI(){
      const statsDiv=document.getElementById("statsArea");
      if(!solves.length){
        statsDiv.innerHTML = "<div class='note'>No solves yet. Press SPACE to start your first solve.</div>";
        return;
      }
      const last = solves[solves.length-1].toFixed(2);
      const bestSingle = (bests.bestSingle??Math.min(...solves)).toFixed(2);
      const mean = average(solves).toFixed(2);
      const stdev = stdDev(solves).toFixed(2);

      const ao5 = computeAo(5);
      const ao12 = computeAo(12);

      const bestAo5 = bests.bestAo5!=null ? bests.bestAo5.toFixed(2) : (solves.length>=5 ? ao5.toFixed(2) : "—");
      const bestAo12 = bests.bestAo12!=null ? bests.bestAo12.toFixed(2) : (solves.length>=12 ? ao12.toFixed(2) : "—");

      statsDiv.innerHTML = `
        <div class="q">Last solve: ${last}s</div>
        <div class="q">Best single: ${bestSingle}s</div>
        <div class="q">Mean of all: ${mean}s</div>
        <div class="q">Std Dev: ${stdev}</div>
        <div class="q">Current Ao5: ${ao5!=null ? ao5.toFixed(2)+"s" : "—"}</div>
        <div class="q">Current Ao12: ${ao12!=null ? ao12.toFixed(2)+"s" : "—"}</div>
        <div class="q">Best Ao5: ${bestAo5}s</div>
        <div class="q">Best Ao12: ${bestAo12}s</div>
        <div class="q">Total solves: ${solves.length}</div>
      `;
    }

    // History table
    function renderHistory(){
      const el = document.getElementById('historyArea');
      if(!solves.length){ el.innerHTML = "<div class='note'>No solves yet.</div>"; return; }
      const rows = solves.map((t,i)=>`<tr><td>#${i+1}</td><td>${t.toFixed(2)}s</td></tr>`).join('');
      el.innerHTML = `
        <table>
          <tr><th>Index</th><th>Time</th></tr>
          ${rows}
        </table>
      `;
    }

    // Graph
    function drawChart(){
      const canvas=document.getElementById('chart');
      if(!canvas) return;
      const ctx=canvas.getContext('2d');
      ctx.clearRect(0,0,canvas.width,canvas.height);

      if(solves.length<2){
        ctx.fillStyle="#fff";
        ctx.fillText("Complete at least 2 solves to see the graph.", 20, 30);
        return;
      }

      // Determine scale
      const maxT = Math.max(...solves);
      const minT = Math.min(...solves);
      const padding = 10;
      const yRange = (maxT - minT) || 1;

      // Plot line
      ctx.strokeStyle="#5fe3a1";
      ctx.lineWidth=2;
      ctx.beginPath();
      solves.forEach((t,i)=>{
        const x = padding + (i*(canvas.width - 2*padding)/(solves.length-1));
        const y = canvas.height - padding - ((t - minT) * (canvas.height - 2*padding) / yRange);
        if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      });
      ctx.stroke();

      // Trend line (simple least squares)
      const n=solves.length;
      const xs = solves.map((_,i)=>i);
      const ys = solves;
      const meanX = average(xs);
      const meanY = average(ys);
      const num = xs.reduce((acc,i)=> acc + (i-meanX)*(ys[i]-meanY), 0);
      const den = xs.reduce((acc,i)=> acc + (i-meanX)*(i-meanX), 0) || 1;
      const m = num/den;
      const b = meanY - m*meanX;

      ctx.strokeStyle="#ffffff88";
      ctx.beginPath();
      for(let i=0;i<n;i++){
        const t = m*i + b;
        const x = padding + (i*(canvas.width - 2*padding)/(n-1));
        const y = canvas.height - padding - ((t - minT) * (canvas.height - 2*padding) / yRange);
        if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.stroke();
    }

    // Timer helpers
    function average(arr){ return arr.length ? arr.reduce((a,b)=>a+b,0)/arr.length : 0; }
    function stdDev(arr){
      if(!arr.length) return 0;
      const m = average(arr);
      return Math.sqrt(arr.reduce((s,v)=> s + (v-m)**2, 0) / arr.length);
    }
    function computeAo(n){
      if(solves.length < n) return null;
      const sub = solves.slice(-n);
      // WCA Ao excludes fastest and slowest — optional. Here we use simple mean.
      return average(sub);
    }
    function resetSession(){
      if(!confirm("Reset session? This clears all solves and bests.")) return;
      solves = [];
      bests = {bestSingle:null, bestAo5:null, bestAo12:null};
      setSolves(solves);
      setBests(bests);
      renderTimer();
    }
    function exportCSV(){
      if(!solves.length){ alert("No solves to export."); return; }
      const lines = ["index,time_s"];
      solves.forEach((t,i)=> lines.push(`${i+1},${t.toFixed(2)}`));
      const blob = new Blob([lines.join("\n")], {type:"text/csv"});
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url; a.download = "cubing_hub_solves.csv";
      document.body.appendChild(a); a.click();
      document.body.removeChild(a); URL.revokeObjectURL(url);
    }

    // Boot menu again to ensure clean handlers
    function backToMenu(){ document.onkeydown=null; renderMenu(); }
  </script>
</body>
</html>